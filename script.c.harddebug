#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>
#include <assert.h>
#include "script.h"
//#include "med.h"
//#include "command.h"

extern buffer_t* file;

#ifdef COMPILE_SCRIPT

#define MAX_ARG 128

#define DEFAULT_MEMORY 256

#define _LABEL -2
#define _EOB -1
#define _EMPTY_LINE 0
#define _SUCCESS 1

#define REPL_LBL 1

#define NO_INSTR_INCREMENT 1

#define INVAL_CHAR 1
#define TOO_MANY_ARGS 2
#define TOO_FEW_ARGS 3
#define INVAL_COMM 4
#define EMPTY_LINE 5
#define NO_PROG_NAME 6
#define INVAL_VAR 7
#define INVAL_LABEL 8

#define \
abort_compilation(err)\
 error = err;\
 pr_error();\
 free_instr();\
 free_mem();\
 free_labels();\
 return NULL;
 

int isalnum_(char c);
int isspace_(char c);

static lang_command commnd[] =
{
	{"jump", 1, 2, jump},
	{"assign", 2, 1, assign},
	{"increment", 1, 1, increment},
	{"print", 1, 1, print},
};

static int ncomm = sizeof(commnd)/sizeof(lang_command);

static lang_instr *instruct;

static lang_instr *next_instr;

static lang_instr *next_instr;

static int exec_flag;

static symbol_t *var_head;

static symbol_t *lbl_head;

static int error;

static int ln;//line no

static line_t* line;

static int nlines;

static int token_n;

static char* token[MAX_ARG];// parsed string

script_t *scr;

int
init()
{
/*
	 if (scr->tail)
	 	scr->tail = scr->tail->next;	 
	 scr->head = scr->tail = malloc(sizeof(lang_instr));
	 scr->tail->next = NULL;
	 
*/	 
 instruct = 0;
 next_instr = 0;
 var_head = 0;
 lbl_head = 0;
 token_n = 0;
// strcpy(token[MAX_ARG], "");
}

int 
make_var_list()
{
 return 0;
}

int 
make_label_list()
{
 return 0;
}

int
jump(void* arg1, void* arg2)
{
 next_instr = (lang_instr*)arg1;
 exec_flag |= NO_INSTR_INCREMENT;
 return 0;
}

int
define_var(void* name, void* not_used)
{
/*
 
 var = realloc(var, sizeof(variable) * ++var_count);
 var[var_count-1].name = strdup(name);
 var[var_count-1].p = malloc(sizeof(int));
 *(var[var_count-1].p) = 0;
*/
 
 return 0;
}

int
assign(void* arg1, void* arg2)
{
 *(int*)arg1 = *(int*)arg2;
 return 0;
}

int
print(void* arg1, void* arg2)
{
 printf("%d\n", *(int*)arg1);
 return 0;
}

int
increment(void* arg1, void* arg2)
{
 (*(int*)arg1)++;
 return 0;
}

void
pr_error()
{
 fprintf(stderr, "line %d:", line->no);
 switch (error) {
 case INVAL_CHAR:
 	fprintf(stderr, "invalid character\n");
 	break;
 case TOO_MANY_ARGS:
 	fprintf(stderr, "too many arguments\n");
 	break;
 case TOO_FEW_ARGS:
 	fprintf(stderr, "too few arguments\n");
 	break;
 case INVAL_COMM:
 	fprintf(stderr, "invalid command\n");
 	break;
 case INVAL_VAR:
 	fprintf(stderr, "invalid variable\n");
 	break;
 case INVAL_LABEL:
 	fprintf(stderr, "invalid label\n");
 	break;
 case EMPTY_LINE:
 	fprintf(stderr, "empty line\n");
 	break;
 default:
 	fprintf(stderr, "error %d\n", error);
 	break;
 	
 }
 fprintf(stderr, "token[0]:%s\n", token[0]);
 fprintf(stderr, "token[1]:%s\n", token[1]);
}

int
parse_line(char* s)
{
assert (s != NULL);
/*
{
printf("s==NULL\n");
exit(3);
}
*/

 int i;
 static char str[MAX_LINE];
 
 strcpy(str, s);
 
 for (i = 0; str[i] && str[i] != ':'; i++);
 
 if (str[i] == ':')
 {
 	str[i] = 0;
 	i--;
 	for (; i >= 0 && isalnum(str[i]); i--);
 	i++;
 	token[0] = str + i;
 	return _LABEL;
 }
 
 for (i = 0; isspace_(str[i]); i++);
 
 if (str[i] == '\0') 
 {
 	printf("_EMPTY_LINE\n");
 	return _EMPTY_LINE;
 }
 	
 for (token_n = 0; token_n < MAX_ARG && str[i] != '\0'; token_n++)
 { 
	 token[token_n] = str + i;
	 for (; isalnum_(str[i]); i++);
	 if (str[i] == '\0')
	 {
	 	str[i] = 0;
	 	i++;
	 	break;
	 }
	 str[i] = 0;
	 i++;
	 for (; isspace_(str[i]); i++);
	 if (str[i] == '\0')
	 {
//	 	ln++;
 	 	break;
	 }
 }
	 token_n = token_n + 1;
	 
 return token_n;
}

//static lang_instr *instruct;

script_t*
compile(line_t* head)
{
 init();
 int h, i, j, l, m, ret;
 int is_label = 0;
 symbol_t *tmp, *var, *lbl;
 lang_instr *instr;
 
/* init line numbers */ 
 for (i = 0, line = head; line; line = line->forw, i++)
 	line->no = i + 1;
 	
 line = head;
 	
 
 scr = malloc(sizeof(script_t));
 
 while((ret = parse_line(line->str)) == _EMPTY_LINE)
 	line = line->forw;
// fprintf(stderr, "%s\n", line->str);
 
 /* search 'program' */
 if (strcmp(token[0], "program") != 0 || token[1] == NULL)
 	scr->name = "program 1";// [i]
 else
 {
 	scr->name = strdup(token[1]);
 	line = line->forw;
 }
 
 /* search 'memory' */
 
 while((ret = parse_line(line->str)) == _EMPTY_LINE)
 	line = line->forw;
 
// printf("line->str:%s\n", line->str); getchar();
 if (strcmp(token[0], "memory") != 0 || token[1] == NULL)
 {
 	 scr->memory = DEFAULT_MEMORY;
	 scr->memory_pool = malloc(DEFAULT_MEMORY);
 }
 else
 {
	 scr->memory = atoi(token[1]);// strol, check return value of malloc
	 scr->memory_pool = malloc(scr->memory);
	 line = line->forw;
 }
 scr->memory_pos = scr->memory_pool;
 
 /* search variable definition */
 
 
 while((ret = parse_line(line->str)) == _EMPTY_LINE)
 	line = line->forw;
 
 
 if (strcmp(token[0], "defvar") == 0)
 {
 	for (i = 1; i < token_n; i++)
 	{
	 	var = malloc(sizeof(symbol_t));
	 	var->name = strdup(token[i]);
	 	var->p = (int*)(scr->memory_pos);
	 	scr->memory_pos += sizeof(int);
	 	var->next = var_head;
	 	var_head = var;
	} 
for (var = var_head; var; var = var->next)	
	printf("var:%s/%p\n", var->name, var->p);
	
	line = line->forw;
 }
 else
 {
 }
 
/* 
printf("............\n"); 
 for(i = 0, var = var_head; var; var = var->next, i++)
 	printf("%s\n", var->name);
 printf("number of variables: %d\n", i);
printf("............\n"); 
*/
 
 /* create instructions */
 
 for (; line; line = line->forw) 
 {
//printf("line->str:%s\n", line->str); 
	 while((ret = parse_line(line->str)) == _EMPTY_LINE)
	 	line = line->forw;
	 	
	 if (ret == _LABEL)
	 {
		printf("label!!!\n");
	 	is_label++;
	 	lbl = malloc(sizeof(symbol_t));
	 	lbl->next = lbl_head;
	 	lbl_head = lbl;
	 	lbl_head->name = strdup(token[0]);
	 	line = line->forw;
	 	/*
		 	printf(".........\n");
		 	for (lbl = lbl_head; lbl != NULL; lbl = lbl->next)
		 	printf("%s\n", lbl->name);
		 	printf(".........\n");
		 */
	 	continue;
	 }
	 	
	 	
	   
	 if (!scr->head)
	 	scr->head = scr->tail = malloc(sizeof(lang_instr));
	 else
	 {
	 	scr->tail->next = malloc(sizeof(lang_instr));
	 	scr->tail = scr->tail->next;	 
	 }
	 scr->tail->next = NULL;
 	
 	/* assign labels */
 	while(is_label)
 	{
		printf("is_label\n");
 		lbl = lbl_head;
 		lbl->p = (int*)scr->tail;
 		lbl = lbl->next;
 		is_label--;
 	}
	 
	 
	 /* search command */

	 for (j = 0; j < ncomm /*&& (strcmp(token[0], commnd[j].name) != 0)*/; j++);
	 for (j = 0; j < ncomm && (strcmp(token[0], commnd[j].name) != 0); j++);
	 if (j == ncomm) 
	 {
	 	abort_compilation(INVAL_COMM);
	 }
	 
	 scr->tail->func = commnd[j].func;
	 	
	 for (i = 0; i < token_n && i < 2 && i < commnd[j].nargs; i++)
	 { 
		 if (isdigit(*token[i+1]))
		 {
			 scr->tail->arg[i] = (int*)malloc(sizeof(int));
			 *(int*)scr->tail->arg[i] = atoi(token[i+1]);
		 }
		 else
		 if (commnd[j].flags & ACCEPT_VAR)
		 {
		 	for (var = var_head; var != NULL; var = var->next)
			if (strcmp(var->name, token[i+1]) == 0)
			{
				scr->tail->arg[i] = var->p;
//				printf("command[%d].name: %s\n", j, commnd[j].name);
				break;
			}
			else
			{
			}
			if (var == NULL)
			{
				abort_compilation(INVAL_VAR);
			}
		 }
		 else
		 if (commnd[j].flags & ACCEPT_LABEL && scr->tail->arg[1] != (void*)REPL_LBL)
		 {
		 	scr->tail->arg[0] = strdup (token[i+1]);
		 	scr->tail->arg[1] = (void*)REPL_LBL;
		 }
	 }// i < token_n...
 }//for (; line...
 
	
/* "second pass" */
	
 for (instr = scr->head; instr; instr = instr->next)
 if (instr->arg[1] == (void*)REPL_LBL)
 {
 	for (lbl = lbl_head; lbl; lbl = lbl->next)
 	if (strcmp(instr->arg[0], lbl->name) == 0)
 	{
 		free(instr->arg[0]);
 		instr->arg[0] = lbl->p;
 		break;
 	}
	if (lbl == NULL)
	{
		printf("instr->arg[0]:%s\n", (char*)instr->arg[0]);
		abort_compilation(INVAL_LABEL);
	}
 }
 
 return scr;
}


void
pr_instr(script_t* scr)
{
 lang_instr* pinstr;
 int j;
 printf("all instructions:\n");
 for (pinstr = scr->head; pinstr != NULL; pinstr = pinstr->next)
 {
 	for (j = 0; j < ncomm; j++)
 		if (commnd[j].func == pinstr->func)
 			printf("command:%s\n", commnd[j].name);
 }
 printf("end instructions\n");
 
 /*
 for (j = 0; j < ncomm; j++)
 if (commnd[j].func == scr->tail->func)
 		printf("tail->command:%s\n", commnd[j].name);
*/ 		
}

int
exec_script(script_t* scr)
{
 int i;
 int j;
 symbol_t *lbl;
 
 if (!scr)
 {
 	fprintf(stderr, "exec_script: can't execute script %p\n", scr);
 	return 1;
 }
 line_t *head = file->cur_line;
 for (;head->backw; head = head->backw);
 for (line = head; line != NULL; line = line->forw)
 
 printf("labels:\n"); 	
 for (lbl = lbl_head; lbl != NULL; lbl = lbl->next)
 	printf("lbl->p:%p\n", lbl->p);
 	
 printf("all instructions:\n"); 	
 for (i = 0, next_instr = scr->head; next_instr != NULL; next_instr = next_instr->next, i++)
 {
 	printf("next_instr:%p\n", next_instr);
 	for (j = 0; j < ncomm; j++)
 		if (commnd[j].func == next_instr->func)
 		printf("%s\n\n", commnd[j].name);
 }
 printf("i:%d\n", i);
// lang_instr* pinstr;
 printf("executed instructions:\n"); 	
 for (i = 0, next_instr = scr->head; next_instr != NULL; i++)
 {
 	next_instr->func(next_instr->arg[0], next_instr->arg[1]);
 	if (!(exec_flag & NO_INSTR_INCREMENT))
 		next_instr = next_instr->next;
 	else
 		exec_flag &= ~NO_INSTR_INCREMENT;
 		
// 	printf("next_instr:%p\n", next_instr);
 }
 	
 printf("exec_script:success:executed %d instructions\n", i); 	
 return 0;
}

int
free_comm()
{
 return 0;
}

int
free_instr()
{
 return 0;
}

int
free_mem()
{
 return 0;
}

int
free_labels()
{
 return 0;
}

#endif